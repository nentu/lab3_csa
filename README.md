# Brainfuck. Транслятор и модель

- Преподаватели, Пенской Александр Владимирович.
- `asm | acc | harv | mc -> hw | tick -> instr | struct | stream | port | pstr | prob1 | cache`
- Базовый вариант.

## Язык программирования

Используется форма БНФ

`N` - любое число вмещающееся в int64

`text` - символьный текст из кодировки ascii любой длины

``` ebnf
program ::= оператор | метка

<метка> ::= "text:" <данные>| "text:" <данные> <комментарий> |
            "text:" <оператор> | "text:" <оператор> <комментарий>
<данные> ::= <число> | "<резерв>" | <текст>

<число> :: "0xN"
<резерв> :: "(0xN)"
<текст> :: '"text"'

<оператор> ::= <оп_код> <аргументы> | <оп_код> <аргументы> <комментарий>
<комментарий> ::= "//text"
<оп_код> ::= "inc" | "dec" | "cls" | "neg" | "load" | "store" | "add" | "sub" |
            "jmp" | "jmpz" | "input" | "output" | "hlt" | "inp" | "outp"
<аргументы> ::= <литерал> |
                <прямая адресация> | 
                <загрузка адреса ссылки> |
                <косвенная адресация>
<литерал> ::= "0xN"
<прямая адресация> ::= "label"
<загрузка адреса ссылки> ::= "&label"
<косвенная адресация> ::= "(label)"

```

Код выполняется последовательно.

Операции:

См. в разделе "Система команд" -> "Набор инструкций"

Любые другие символы в строке после `//` трактуются как комментарии

Память выделяется статически, при запуске модели.
Видимость данных -- глобальная.
Поддержка литералов -- присутствует.

## Организация памяти

Модель памяти процессора Гарвардская (отдельная память для команд и данных):

1. Память команд. Машинное слово -- не определено. Реализуется списком словарей, описывающих инструкции (одно слово --
   одна ячейка).
2. Память данных. Машинное слово -- 64 бит, знаковое. Линейное адресное пространство. Реализуется списком чисел.

Адресация:

| name  | code    | desc                     |
|-------|---------|--------------------------|
| dir   | 0xN     | Прямая загрузка литерала |
| addr  | &label  | Загрузка адреса метки    |
| val   | label   | Прямая адресация         |
| indir | (label) | Косвенная адресация      |
| no    | _       | Без операнда             |

Механика отображения *данных* на процессор:

После того как транслятор обработал исходный код в память данных последовательно загружаются данные в виде массива целых
чисел.
Если при одном выделении памяти было использовано больше 1 ячейки, то перед данным в памяти пишется их количество.

Механика отображения *команд* на процессор:

Список словарей копируется в память команд.

Тк представлена аккумуляторная архитектура, то программисту доступен только аккумулятор и память данных.
Ячейки памяти данных могут и должны использоваться в качестве переменных

В текущей реализации константы отсутствуют

Работа с переменными происходит за счёт работы с памятью данных через метки

Выделять память можно 3 способами

- ввод значения (число или один символ)
- резерв на заданное кол-во ячеек
- Ввод строки из символов

Все символы заменяются на из ascii коды.
Во 2 и 3 пунктах перед данными в память пишется количество занятых ячеек

## Система команд

Особенности процессора:

- Машинное слово -- 64 бит, знаковое.
- Доступ к памяти данных осуществляется по адресу, хранящемуся в специальном регистре `data_address`.
  В данный регистр загружается значение аргумента.
  При косвенной адресации после этого в `data_address` загружается значение памяти текущей ячейки.
- Обработка данных осуществляется по текущему адресу операциями АЛУ.
- Поддерживается ввод/вывод данных через соответственные буферы.
- Поддерживается ввод и вывод в 2 дополнительных порта
- Поток управления:
    - инкремент `PC` после каждой инструкции;
    - условный (`jmpz`) и безусловный (`jmp`) переходы (использование см. в разделе транслятор).

### Набор инструкций

| op_code | типы адресации        | Мнемоника             |
|---------|-----------------------|-----------------------|
| inc     | no                    | acc++                 |
| dec     | no                    | acc--                 |
| cls     | no                    | acc <= 0              |
| neg     | no                    | acc <= -acc           |
| load    | dir, addr, val, indir | acc <- i              |
| store   | val, indir            | acc -> mem            |
| add     | val, dir              | acc+= i               |
| sub     | val, dir              | acc-=i                |
| jmp     | i_val                 | IP <- arg             |
| jmpz    | i_val                 | IP <- arg (if z_flag) |
| input   | no                    | read from stream      |
| output  | no                    | write to stream       |
| hlt     | no                    | stop                  |
| inp     | dir                   | input from port       |
| outp    | dir                   | output to port        |

### Кодирование инструкций

- Машинный код сериализуется в список JSON.
- Один элемент списка -- одна инструкция.
- Индекс списка -- адрес инструкции. Используется для команд перехода.
- В регистр `IR` попадает закодированная инструкция по следующей формуле: `<op_code_id> * 10 + <address_type_id>`
-

Пример:

```json
{
  "code": [
    {
      "opcode": "add",
      "arg": 5,
      "address_type": "direct_addr",
      "term": [
        1,
        // номер строки исходного "очищенного" файла
        "add"
        // сам терм
      ]
    }
  ]
}
```

где:

- `opcode` -- строка с кодом операции;
- `arg` -- аргумент (знаковое число);
- `address_type` -- Тип адресации;
- `term` -- информация о связанном месте в исходном коде.

Типы данных в модуле [isa](./isa.py), где:

- `Opcode` -- перечисление кодов операций;
- `Address` -- перечисление типов адресации.
- `operation_to_code` -- кодирование операции и адресации в число.
- `code_to_operation` -- декодирование операции и адресации из числа.

## Транслятор

Интерфейс командной строки: `translator.py <input_file> <target_file>`

Реализовано в модуле: [translator](./translator.py)

Этапы трансляции (функция `translate`):

1. Очистка кода: избавление от отступов, комментариев, пустых строк
2. Генерация блока данных и инструкций и сохранение адресов меток
3. Подстановка адресов меток в инструкции

Правила генерации машинного кода:

- один строка языка -- одна инструкция;
- для всех команд прямое отображение;
- Все символы в строке после `//` считаются комментариями и не учитываются при генерации кода
- Между `opcode` и аргументом должен быть ровно 1 пробел
- После метки через `": "` сразу должна идти либо инструкция, либо выделение памяти
- Секция данных начинается со строки `section .data`
- Затем идёт секция кода, которая начинается со строки `section .code`

## Модель процессора

Интерфейс командной строки: `machine.py <machine_code_file> <input_file>`

Реализовано в модуле: [machine](./control_unit.py).

### DataPath

Реализован в модуле: [Datapath](./data_path.py).

`data_memory` -- однопортовая память, поэтому либо читаем, либо пишем.
`instuction_memory` -- однопортовая память, поэтому либо читаем, либо пишем.

Сигналы (обрабатываются за один такт, реализованы в виде методов класса):

- `get_instruction_signal` -- поместить выбранную инструкцию из регистра `IP` на шину `IR`
- `do_alu_signal` -- сигнал на выполнение АЛУ операции и выставление результатов на шину аккумулятора
- `get_data_signal` -- поместить выбранную ячейку из регистра `ADDR` на шину аргумента АЛУ и `ADDR`
- `set_data_signal` -- записать в память данных значение `acc` по адресу из `ADDR`
- `latch_reg_ip_signal` -- защелкнуть регистр `IP`
- `latch_reg_ir_signal` -- защелкнуть регистр `IR`
- `latch_reg_addr_signal` -- защелкнуть регистр `ADDR`
- `set_mux_jmp_type` -- установка мультиплексора на тип перехода: 0 - обычный переход, 1 - 1 - `Z_flag`
- `set_mux_ip_signal` -- установка мультиплексора на `IP`: 0 - из операнда инструкции, 1 - `IP+1`
- `set_mux_addr_signal` -- установка мультиплексора на `ADDR`: 1 - операнда инструкции; 0 - из выхода памяти
- `set_mux_alu_signal` -- установка верхнего мультиплексора на ввод АЛУ: 0 - операнда инструкции; 1 - значение шины из
  памяти данных
- `set_mux_alu_input_signal` -- установка нижнего мультиплексора на ввод АЛУ
  0 - верхний мультиплексор; 1 - `input_buffer`; 2, 3 - ввод из портов 1 и 2 соответственно. (работа с буферами
  реализована на Python)
- `latch_acc_signal` -- защелкнуть значение аккумулятора и выставить флаг `Z_flag`
- `output_signal` -- записать аккумулятор в порт вывода (обработка на Python)
- `port_1_signal` -- записать аккумулятор в порт вывода для устройства 1
- `port_2_signal` -- записать аккумулятор в порт вывода для устройства 2

Флаги:

- `Z_flag` -- отражает наличие нулевого значения в аккумуляторе.

### ControlUnit

``` text
   +------------------(+1)-------+
   |                             |
   |    latch_program_counter    |
   |                  |          |
   |   +-----+        v          |
   +-->|     |     +---------+   |    +---------+
       | MUX |---->| program |---+--->| program |
   +-->|     |     | counter |        | memory  |
   |   +-----+     +---------+        +---------+
   |      ^                               |
   |      | sel_next                      | current instruction
   |      |                               |
   +---------------(select-arg)-----------+
          |                               |      +---------+
          |                               |      |  step   |
          |                               |  +---| counter |
          |                               |  |   +---------+
          |                               v  v        ^
          |                       +-------------+     |
          +-----------------------| instruction |-----+
                                  |   decoder   |
                                  |             |<-------+
                                  +-------------+        |
                                          |              |
                                          | signals      |
                                          v              |
                                    +----------+  zero   |
                                    |          |---------+
                                    | DataPath |
                     input -------->|          |----------> output
                                    +----------+
```

Реализован в классе в модуле: [ControlUnit](./control_unit.py).

- mc (реализовано полностью на Python).
- Метод `decode_and_execute_instruction` моделирует выполнение полного цикла инструкции (1-2 такта процессора).
- `step_counter` необходим для многотактовых инструкций;
    - в реализации класс `ControlUnit` отсутствует, т.к. неявно задан потоком управления.

Сигнал:

- `set_MUX` - установка мультиплексора на `IP`: 0 - запись 0 в `IP`, 1 - `IP+1`, 2 - запись значения из декодера в `IP`
- `latch_IP` - защелкнуть `IP`

Функции

- `decode` -- преобразовать код инструкции в адрес в памяти микрокоманд
- `load_mem` -- загрузить память микрокоманд
- `execute` -- выполнение микрокода: каждый "бит" (1/0 в массиве микрокоманды) связан с функцией, которая вызывается,
  передавая в аргумент значение бита (0 - выполняется; 1 - не выполняется)
- `juggernaut` -- **молотить** (выполнять) микроинструкции.

Особенности работы модели:

- Цикл симуляции осуществляется в функции `juggernaut`.
- Шаг моделирования соответствует одной микроинструкции с инкрементированием счётчика `tick`.
- Для журнала состояний процессора используется стандартный модуль `logging`.
- Остановка моделирования осуществляется при:
    - исключении `EmptyBufferException` -- если нет данных для чтения из порта ввода;
    - исключении `HLTException` -- если выполнена инструкция `halt`.

## Тестирование

Тестирование выполняется при помощи golden test-ов.

1. Тесты для языка `bf` реализованы в: [golden_bf_test.py](./golden_test.py). Конфигурации:
    - [golden/hello_world.yml](golden/hello_world.yml) Вывод в буфер "Hello, world!"
    - [golden/io.yml](golden/io.yml) Вывод в буфер вывода тест из буфера ввода
    - [golden/prob1.yml](golden/prob1.yml) Реализации задачки
    - [golden/say_hello.yml](golden/say_hello.yml) Запросить имя, и поздороваться с человеком

Запустить тесты: `poetry run pytest . -v`

Обновить конфигурацию golden tests:  `poetry run pytest . -v --update-goldens`

CI при помощи Github Action:

``` yaml
defaults:
  run:
    working-directory: ./python

jobs:
  test:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: 3.11

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install poetry
          poetry install

      - name: Run tests and collect coverage
        run: |
          poetry run coverage run -m pytest .
          poetry run coverage report -m
        env:
          CI: true

  lint:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: 3.11

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install poetry
          poetry install

      - name: Check code formatting with Ruff
        run: poetry run ruff format --check .

      - name: Run Ruff linters
        run: poetry run ruff check .
```

где:

- `poetry` -- управления зависимостями для языка программирования Python.
- `coverage` -- формирование отчёта об уровне покрытия исходного кода.
- `pytest` -- утилита для запуска тестов.
- `ruff` -- утилита для форматирования и проверки стиля кодирования.

Пример использования и журнал работы процессора на примере `cat`:

Данный алгоритм должен считать символы из потока ввода и выводить в поток вывода пока буфер не закончится

Код алгоритма:

```asm
section .code
    start: input  // чтение из буфера ввода
    output        // запись в буфер вывода
    jmp start     // переход в начало цикла
```

Транслированный код

```json
  {
  "data": [
  ],
  "code": [
    {
      "opcode": "input",
      "arg": 0,
      "address_type": "no_op",
      "term": [
        1,
        "input"
      ]
    },
    {
      "opcode": "output",
      "arg": 0,
      "address_type": "no_op",
      "term": [
        2,
        "output"
      ]
    },
    {
      "opcode": "jmp",
      "arg": 0,
      "address_type": "label_val",
      "term": [
        3,
        "jmp"
      ]
    }
  ]
}
```
Входные данные: 

`test`

Вывод программы
```
test

Tick count: 29, Command count: 13
```

Пример проверки исходного кода:

``` shell
$ poetry run pytest . -v
=================================== test session starts ====================================
platform darwin -- Python 3.12.0, pytest-7.4.3, pluggy-1.3.0 -- /Users/ryukzak/Library/Caches/pypoetry/virtualenvs/brainfuck-NIOcuFng-py3.12/bin/python
cachedir: .pytest_cache
rootdir: /Users/ryukzak/edu/csa/src/brainfuck
configfile: pyproject.toml
plugins: golden-0.2.2
collected 6 items

integration_test.py::test_translator_and_machine[golden/cat.yml] PASSED              [ 16%]
integration_test.py::test_translator_and_machine[golden/hello.yml] PASSED            [ 33%]
integration_test.py::TestTranslatorAndMachine::test_cat_example PASSED               [ 50%]
integration_test.py::TestTranslatorAndMachine::test_cat_example_log PASSED           [ 66%]
integration_test.py::TestTranslatorAndMachine::test_hello_example PASSED             [ 83%]
machine.py::machine.DataPath.signal_wr PASSED                                        [100%]

==================================== 6 passed in 0.14s =====================================
$ poetry run ruff check .
$ poetry run ruff format .
4 files left unchanged
```

| ФИО                     | алг             | LoC | code байт | code инстр. | инстр. | такт. | вариант                                                                                                 |
|-------------------------|-----------------|-----|-----------|-------------|--------|-------|---------------------------------------------------------------------------------------------------------|
| Зайцев Артём Михайлович | hello           | 22  | -         | 15          | 134    | 373   | `asm \| acc \| harv \| mc -> hw \| tick -> instr \| struct \| stream \| port \| pstr \| prob1 \| cache` | 
| Зайцев Артём Михайлович | cat             | 4   | -         | 3           | 13     | 29    | `asm \| acc \| harv \| mc -> hw \| tick -> instr \| struct \| stream \| port \| pstr \| prob1 \| cache` |
| Зайцев Артём Михайлович | hello_user_name | 74  | -         | 57          | 369    | 1030  | `asm \| acc \| harv \| mc -> hw \| tick -> instr \| struct \| stream \| port \| pstr \| prob1 \| cache` |
| Зайцев Артём Михайлович | prob1           | 40  | -         | 36          | 5453   | 15090 | `asm \| acc \| harv \| mc -> hw \| tick -> instr \| struct \| stream \| port \| pstr \| prob1 \| cache` |
                                                                    